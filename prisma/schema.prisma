datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

/* ---------- ENUMS ---------- */

enum KnowledgeDocumentType {
  FAQ
  DOCUMENTO
  CONTRATO
  PLAN
  TICKET
  COBRO
  OTRO
}

enum ChatRole {
  USER
  ASSISTANT
  SYSTEM
  TOOL
}

enum ChatChannel {
  WHATSAPP
  WEB
  TELEGRAM
  SMS
  OTHER
}

enum ChatSessionStatus {
  OPEN
  CLOSED
  ARCHIVED
}

/* ---------- EMPRESA / CLIENTE ---------- */

model Empresa {
  id            Int              @id @default(autoincrement())
  nombre        String
  slug          String           @unique   // "nova-sistemas", etc.
  activo        Boolean          @default(true)

  creadoEn      DateTime         @default(now())
  actualizadoEn DateTime         @updatedAt

  clientes      Cliente[]
  documentos    KnowledgeDocument[]
  sesiones      ChatSession[]
  bots          Bot[]           
}

enum BotStatus {
  ACTIVE
  DISABLED
}

model Bot {
  id           Int       @id @default(autoincrement())

  empresa      Empresa   @relation(fields: [empresaId], references: [id], onDelete: Cascade)
  empresaId    Int

  nombre       String
  slug         String    @unique
  descripcion  String?

  // LLM / proveedor
  provider     String    @default("fireworks")
  model        String    @default("accounts/fireworks/models/gpt-oss-120b")

  // üîπ Comportamiento principal (persona)
  // Puedes tratarlo como template: "Eres el asistente de {{empresaNombre}} ..."
  systemPrompt   String   @db.Text

  // üîπ C√≥mo integrar contexto de RAG e historial
  contextPrompt  String?  @db.Text // "Te dar√© contexto de base de conocimiento: {{context}} ..."
  historyPrompt  String?  @db.Text // "A continuaci√≥n tienes el historial reciente: {{history}} ..."

  // üîπ Estilo de salida (WhatsApp / web / etc.)
  outputStyle    String?  @db.Text
  // Ej: "Responde como mensaje de WhatsApp: sin tablas, solo texto plano, negritas con *...* y emojis."

  // üîπ Par√°metros del modelo (performance en el sentido de generaci√≥n)
  maxCompletionTokens Int?    @default(500)
  temperature         Float   @default(0.7)
  topP                Float?  @default(0.9)
  frequencyPenalty    Float?  @default(0.2)
  presencePenalty     Float?  @default(0.0)

  maxHistoryMessages  Int?    @default(15)
  status        BotStatus @default(ACTIVE)

  creadoEn      DateTime  @default(now())
  actualizadoEn DateTime  @updatedAt

  sesiones       ChatSession[]
  // knowledgeLinks BotKnowledge[]
  // channelConfigs BotChannelConfig[]
}


model Cliente {
  id            Int       @id @default(autoincrement())

  empresa       Empresa   @relation(fields: [empresaId], references: [id], onDelete: Cascade)
  empresaId     Int

  nombre        String?
  telefono      String          // ID l√≥gico principal
  uuid          String? @unique // UUID oficial del CRM (si aplica)
  crmUsuarioId  Int?            // si tu CRM usa id num√©rico y te sirve

  creadoEn      DateTime  @default(now())
  actualizadoEn DateTime  @updatedAt

  sesiones      ChatSession[]

  // Historial completo de WhatsApp de este cliente
  whatsappHistory WhatsappMessage[]
  // Un tel√©fono no se repite dentro de la misma empresa
  @@unique([empresaId, telefono])
}

/* ---------- CHAT ---------- */

model ChatSession {
  id                   Int               @id @default(autoincrement())

  empresa              Empresa           @relation(fields: [empresaId], references: [id], onDelete: Cascade)
  empresaId            Int

  // üëá Qu√© bot atendi√≥ esta sesi√≥n
  bot                  Bot?              @relation(fields: [botId], references: [id])
  botId                Int?

  cliente              Cliente?          @relation(fields: [clienteId], references: [id])
  clienteId            Int?

  telefono             String
  canal                ChatChannel
  estado               ChatSessionStatus @default(OPEN)

  whatsappMessages WhatsappMessage[]

  // Integraci√≥n con CRM: √∫ltimo ticket creado en esta sesi√≥n
  ultimoTicketCrmId    String?
  ultimoTicketCreadoEn DateTime?

  iniciadoEn           DateTime          @default(now())
  cerradoEn            DateTime?
  creadoEn             DateTime          @default(now())
  actualizadoEn        DateTime          @updatedAt

  mensajes             ChatMessage[]

  @@index([empresaId, telefono, canal, estado])
}

model ChatMessage {
  id         Int        @id @default(autoincrement())

  session    ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId  Int

  rol        ChatRole
  contenido  String
  tokens     Int?

  creadoEn   DateTime    @default(now())
  actualizadoEn DateTime         @updatedAt

  @@index([sessionId, creadoEn])
}

/* ---------- RAG: DOCUMENTOS / CHUNKS ---------- */

model KnowledgeDocument {
  id          Int                   @id @default(autoincrement())

  empresa     Empresa               @relation(fields: [empresaId], references: [id], onDelete: Cascade)
  empresaId   Int

  tipo        KnowledgeDocumentType
  externoId   Int?
  origen      String?

  titulo      String
  descripcion String?
  textoLargo String? @db.Text

  // textoLargo   String
  creadoEn      DateTime            @default(now())
  actualizadoEn DateTime            @updatedAt

  chunks      KnowledgeChunk[]

  @@index([empresaId, tipo])
}

model KnowledgeChunk {
  id         Int               @id @default(autoincrement())

  document   KnowledgeDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId Int

  indice     Int
  texto      String

  embedding  Unsupported("vector(4096)")
  tokens     Int?

  creadoEn       DateTime @default(now())
  actualizadoEn  DateTime @updatedAt

  @@index([documentId, indice])
}

/* ---------- RAG: DOCUMENTOS / CHUNKS ---------- */


/* ---------- WHATSAPPP: PERSISTENCIA DE CHATS ---------- */
model WhatsappMessage {
  id        Int   @id @default(autoincrement()) // ID interno nuestro
  
  // üÜî IDENTIFICADORES DE META
  // El 'wamid' es vital para actualizar estados (doble check) y manejar respuestas
  wamid     String   @unique 
  
  // üîó RELACIONES
  // Opcional: Saber a qu√© sesi√≥n de IA perteneci√≥ este mensaje (si hubo una)
  chatSessionId Int?
  chatSession   ChatSession? @relation(fields: [chatSessionId], references: [id])
  
  // Relaci√≥n con tu Cliente (fundamental para historial por contacto)
  clienteId     Int?
  cliente       Cliente?     @relation(fields: [clienteId], references: [id])

  // üìû DATOS DE ENV√çO
  direction     WazDirection
  from          String       // N√∫mero del que env√≠a (Cliente o Bot)
  to            String       // N√∫mero del que recibe
  
  // üì¶ CONTENIDO
  type          WazMediaType
  body          String?      @db.Text // El texto del mensaje o el "Caption" de la foto
  
  // üñºÔ∏è MULTIMEDIA (Aqu√≠ usas lo de DO Spaces)
  mediaUrl      String?      // URL p√∫blica del archivo
  mediaMimeType String?      // image/jpeg, audio/ogg
  mediaSha256   String?      // Para evitar re-subir el mismo archivo
  
  // ‚úÖ ESTADOS (Webhooks actualizan esto)
  status        WazStatus    @default(SENT)
  errorCode     String?      // Si status es FAILED, aqu√≠ guardas por qu√©
  errorMessage  String?

  // ‚Ü©Ô∏è CONTEXTO (Respuestas)
  // Si este mensaje es respuesta a otro, guardamos el wamid del padre
  replyToWamid  String?      
  
  // üìÖ FECHAS
  timestamp     BigInt       // Timestamp original de WhatsApp (Unix)
  creadoEn      DateTime     @default(now())
  actualizadoEn DateTime     @updatedAt

  @@index([wamid])
  @@index([clienteId])
  @@index([status])
}
/* ---------- WHATSAPPP: PERSISTENCIA DE CHATS ---------- */


// ENUMS
// Direcci√≥n del mensaje: ¬øEntra al servidor o Sale del servidor?
enum WazDirection {
  INBOUND  // Cliente -> Bot
  OUTBOUND // Bot -> Cliente
}

// Estado de entrega (El "Check")
enum WazStatus {
  SENT      // Un check gris (Enviado a Meta)
  DELIVERED // Doble check gris (Lleg√≥ al celular)
  READ      // Doble check azul (Le√≠do)
  FAILED    // Error (No sali√≥)
}

// Tipo de contenido (Para saber c√≥mo renderizarlo en el UI)
enum WazMediaType {
  TEXT
  IMAGE
  AUDIO     // Notas de voz
  VIDEO
  DOCUMENT  // PDFs
  STICKER
  LOCATION
  TEMPLATE  // Plantillas de marketing
  INTERACTIVE // Botones y listas
  UNKNOWN
}






